{"version":3,"sources":["../src/index.ts","../src/support/supports-relative-time-format.ts","../node_modules/tslib/tslib.es6.js","../src/unit/singular-relative-time-unit.ts","../src/util/to-object.ts","../src/relative-time-format/unicode-extension/unicode-extension.ts","../src/relative-time-format/default-locale/get-default-locale.ts","../src/relative-time-format/matcher/best-available-locale/best-available-locale.ts","../src/relative-time-format/matcher/lookup-matcher/lookup-matcher.ts","../src/assert/is-record.ts","../src/util/same-value.ts","../src/relative-time-format/resolve-locale/resolve-locale.ts","../src/relative-time-format/matcher/best-fit-matcher/best-fit-matcher.ts","../src/assert/is-list.ts","../src/relative-time-format/supported-locales/lookup-supported-locales.ts","../src/relative-time-format/supported-locales/supported-locales.ts","../src/relative-time-format/supported-locales/best-fit-supported-locales.ts","../src/relative-time-format/internal-slot/internal-slot.ts","../src/relative-time-format/numbering-systems/numbering-systems.ts","../src/relative-time-format/partition-relative-time-pattern/partition-relative-time-pattern.ts","../src/relative-time-format/partition-number-pattern/partition-number-pattern.ts","../src/relative-time-format/make-parts-list/make-parts-list.ts","../src/relative-time-format/resolve-plural/resolve-plural.ts","../src/relative-time-format/relative-time-format/relative-time-format.ts","../src/relative-time-format/format-relative-time/format-relative-time.ts","../src/relative-time-format/format-relative-time-to-parts/format-relative-time-to-parts.ts","../src/patch/patch.ts"],"names":["tslib_1.__values"],"mappings":"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","file":"dist.f61e6673.js","sourceRoot":"../../src/playground","sourcesContent":["import {SUPPORTS_RELATIVE_TIME_FORMAT} from \"./support/supports-relative-time-format\";\nimport {patch} from \"./patch/patch\";\n\nif (!SUPPORTS_RELATIVE_TIME_FORMAT) {\n\tpatch();\n}\n","export const SUPPORTS_RELATIVE_TIME_FORMAT = \"RelativeTimeFormat\" in Intl;\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import {RelativeTimeUnit} from \"./relative-time-unit\";\n\nexport type SingularRelativeTimeUnit = \"second\" | \"minute\" | \"hour\" | \"day\" | \"week\" | \"month\" | \"quarter\" | \"year\";\n\nexport type ExtendedSingularRelativeTimeUnit =\n\t| SingularRelativeTimeUnit\n\t| \"second-narrow\"\n\t| \"second-short\"\n\t| \"minute-narrow\"\n\t| \"minute-short\"\n\t| \"hour-narrow\"\n\t| \"hour-short\"\n\t| \"day-narrow\"\n\t| \"day-short\"\n\t| \"week-narrow\"\n\t| \"week-short\"\n\t| \"month-narrow\"\n\t| \"month-short\"\n\t| \"quarter-narrow\"\n\t| \"quarter-short\"\n\t| \"year-narrow\"\n\t| \"year-short\";\n\nconst VALID_SINGULAR_RELATIVE_TIME_UNIT_VALUES: SingularRelativeTimeUnit[] = [\"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\"];\n\nexport const VALID_EXTENDED_SINGULAR_RELATIVE_TIME_UNIT_VALUES: ExtendedSingularRelativeTimeUnit[] = [\n\t...VALID_SINGULAR_RELATIVE_TIME_UNIT_VALUES,\n\t\"second-narrow\",\n\t\"second-short\",\n\t\"minute-narrow\",\n\t\"minute-short\",\n\t\"hour-narrow\",\n\t\"hour-short\",\n\t\"day-narrow\",\n\t\"day-short\",\n\t\"week-narrow\",\n\t\"week-short\",\n\t\"month-narrow\",\n\t\"month-short\",\n\t\"quarter-narrow\",\n\t\"quarter-short\",\n\t\"year-narrow\",\n\t\"year-short\"\n];\n\n/**\n * Sanitizes a RelativeTimeUnit into a SingularRelativeTimeUnit\n *\n * http://tc39.github.io/proposal-intl-relative-time/#sec-singularrelativetimeunit\n * @param {RelativeTimeUnit} unit\n * @return {SingularRelativeTimeUnit}\n */\nexport function singularRelativeTimeUnit(unit: RelativeTimeUnit): SingularRelativeTimeUnit {\n\t// Assert: Type(unit) is String.\n\tif (typeof unit !== \"string\") {\n\t\tthrow new TypeError(`unit: '${unit}' must be a string`);\n\t}\n\n\t// If unit is \"seconds\", return \"second\".\n\tif (unit === \"seconds\") return \"second\";\n\n\t// If unit is \"minutes\", return \"minute\".\n\tif (unit === \"minutes\") return \"minute\";\n\n\t// If unit is \"hours\", return \"hour\".\n\tif (unit === \"hours\") return \"hour\";\n\n\t// If unit is \"days\", return \"day\".\n\tif (unit === \"days\") return \"day\";\n\n\t// If unit is \"weeks\", return \"week\".\n\tif (unit === \"weeks\") return \"week\";\n\n\t// If unit is \"months\", return \"month\".\n\tif (unit === \"months\") return \"month\";\n\n\t// If unit is \"quarters\", return \"quarter\".\n\tif (unit === \"quarters\") return \"quarter\";\n\n\t// If unit is \"years\", return \"year\".\n\tif (unit === \"years\") return \"year\";\n\n\t// If unit is not one of \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", or \"year\", throw a RangeError exception.\n\tif (!VALID_SINGULAR_RELATIVE_TIME_UNIT_VALUES.some(validUnit => validUnit === unit)) {\n\t\tthrow new RangeError(`Unit: '${unit}' must be one of: ${VALID_SINGULAR_RELATIVE_TIME_UNIT_VALUES.map(val => `\"${val}\"`).join(\", \")}`);\n\t}\n\n\t// Return unit.\n\treturn unit;\n}\n","/* tslint:disable:use-primitive-type no-construct no-any */\n\n/**\n * The abstract operation ToObject converts argument to a value of type Object.\n *\n * https://tc39.github.io/ecma262/#sec-toobject\n * @param {T} argument\n * @return {T extends boolean ? Boolean : T extends number ? Number : T extends string ? String : T extends symbol ? symbol : T}\n */\nexport function toObject<T>(argument: T): T extends boolean ? Boolean : T extends number ? Number : T extends string ? String : T extends symbol ? Symbol : T {\n\tif (argument == null) {\n\t\tthrow new TypeError(`Argument ${argument} cannot be converted to an Object`);\n\t}\n\n\tif (typeof argument === \"boolean\") {\n\t\treturn new Boolean(argument) as any;\n\t}\n\n\tif (typeof argument === \"number\") {\n\t\treturn new Number(argument) as any;\n\t}\n\n\tif (typeof argument === \"string\") {\n\t\treturn new String(argument) as any;\n\t}\n\n\tif (typeof argument === \"symbol\") {\n\t\treturn new Object(argument) as any;\n\t}\n\n\treturn argument as any;\n}\n","/**\n * A Regular Expression that matches Unicode extension sequences\n * @type {RegExp}\n */\nexport const UNICODE_EXTENSION_SEQUENCE_REGEXP = /-u(?:-[0-9a-z]{2,8})+/gi;\n\n/**\n * Removes all Unicode characters from the given string\n * @param {string} str\n * @return {string}\n */\nexport function removeUnicodeExtensionSequences(str: string): string {\n\treturn str.replace(UNICODE_EXTENSION_SEQUENCE_REGEXP, \"\");\n}\n\n/**\n * The abstract operation UnicodeExtensionValue is called with extension, which must be a Unicode locale extension sequence,\n * and String key. This operation returns the type subtags for key.\n * @param {string} extension\n * @param {string} key\n * @returns {string?}\n */\nexport function unicodeExtensionValue(extension: string, key: string): string | undefined {\n\t// Assert: The number of elements in key is 2.\n\tif (key.length !== 2) {\n\t\tthrow new TypeError(`Could not get UnicodeExtensionValue: The given key: '${key}' must have a length of 2`);\n\t}\n\n\t// Let size be the number of elements in extension.\n\tconst size = key.length;\n\n\t// Let searchValue be the concatenation of \"-\", key, and \"-\".\n\tlet searchValue = `-${key}-`;\n\n\t// Let pos be Call(%StringProto_indexOf%, extension, « searchValue »).\n\tlet pos = String.prototype.indexOf.call(extension, searchValue);\n\n\t// If pos ≠ -1, then\n\tif (pos !== -1) {\n\t\t// Let start be pos + 4.\n\t\tconst start = pos + 4;\n\t\t// Let end be start.\n\t\tlet end = start;\n\t\t// Let k be start.\n\t\tlet k = start;\n\t\t// Let done be false.\n\t\tlet done = false;\n\n\t\t// Repeat, while done is false\n\t\twhile (!done) {\n\t\t\t// Let e be Call(%StringProto_indexOf%, extension, « \"-\", k »).\n\t\t\tconst e = String.prototype.indexOf.call(extension, \"-\", k);\n\n\t\t\t// If e = -1, let len be size - k; else let len be e - k.\n\t\t\tconst len = e === -1 ? size - k : e - k;\n\n\t\t\t// If len = 2, then\n\t\t\tif (len === 2) {\n\t\t\t\t// Let done be true.\n\t\t\t\tdone = true;\n\t\t\t}\n\n\t\t\t// Else if e = -1, then\n\t\t\telse if (e === -1) {\n\t\t\t\t// Let end be size.\n\t\t\t\tend = size;\n\n\t\t\t\t// Let done be true.\n\t\t\t\tdone = true;\n\t\t\t}\n\n\t\t\t// Else,\n\t\t\telse {\n\t\t\t\t// Let end be e.\n\t\t\t\tend = e;\n\n\t\t\t\t// Let k be e + 1.\n\t\t\t\tk = e + 1;\n\t\t\t}\n\t\t}\n\t\t// Return the String value equal to the substring of extension consisting of\n\t\t// the code units at indices start (inclusive) through end (exclusive).\n\t\treturn extension.slice(start, end);\n\t}\n\n\t// Let searchValue be the concatenation of \"-\" and key.\n\tsearchValue = `-${key}`;\n\t// Let pos be Call(%StringProto_indexOf%, extension, « searchValue »).\n\tpos = String.prototype.indexOf.call(extension, searchValue);\n\t// If pos ≠ -1 and pos + 3 = size, then\n\tif (pos !== -1 && pos + 3 === size) {\n\t\t// Return the empty String.\n\t\treturn \"\";\n\t}\n\n\t// Return undefined.\n\treturn undefined;\n}\n","import {Locale} from \"../../locale/locale\";\n\n/**\n * Must represent the structurally valid (6.2.2) and canonicalized (6.2.3) BCP 47 language tag for the host environment's current locale.\n *\n * https://tc39.github.io/ecma402/#sec-defaultlocale\n * @type {Locale?}\n */\nlet _defaultLocale: Locale | undefined;\n\n/**\n * Sets the default locale\n * @param {Locale} locale\n */\nexport function setDefaultLocale(locale: Locale): void {\n\t_defaultLocale = locale;\n}\n\n/**\n * The DefaultLocale abstract operation returns a String value representing the structurally valid (6.2.2) and canonicalized (6.2.3) BCP 47 language tag for the host environment's current locale.\n * https://tc39.github.io/ecma402/#sec-defaultlocale\n * @return {Locale | undefined}\n */\nexport function getDefaultLocale(): Locale | undefined {\n\treturn _defaultLocale;\n}\n\n/**\n * Retrieves the default locale if it is set, and throws otherwise\n * @return {Locale}\n */\nexport function ensureDefaultLocale(): Locale {\n\tif (_defaultLocale == null) {\n\t\tthrow new ReferenceError(`Could not determine locale: No default locale has been configured`);\n\t}\n\treturn _defaultLocale;\n}\n","import {Locales} from \"../../../locale/locales\";\nimport {Locale} from \"../../../locale/locale\";\n\n/**\n * The BestAvailableLocale abstract operation compares the provided argument locale,\n * which must be a String value with a structurally valid and canonicalized BCP 47 language tag,\n * against the locales in availableLocales and returns either the longest non-empty prefix of locale\n * that is an element of availableLocales, or undefined if there is no such element. It uses the fallback\n * mechanism of RFC 4647, section 3.4.\n *\n * https://tc39.github.io/ecma402/#sec-bestavailablelocale\n * @param {Locales} availableLocales\n * @param {Locale} locale\n * @return {string}\n */\nexport function bestAvailableLocale(availableLocales: Locales, locale: Locale): string | undefined {\n\t// Let candidate be locale.\n\tlet candidate = locale;\n\t// Repeat\n\twhile (true) {\n\t\t// If availableLocales contains an element equal to candidate, return candidate.\n\t\tif (availableLocales.includes(candidate)) {\n\t\t\treturn candidate;\n\t\t}\n\n\t\t// Let pos be the character index of the last occurrence of \"-\" (U+002D) within candidate.\n\t\tlet pos = candidate.lastIndexOf(\"-\");\n\t\t// If that character does not occur, return undefined.\n\t\tif (pos === -1) return undefined;\n\n\t\t// If pos ≥ 2 and the character \"-\" occurs at index pos-2 of candidate, decrease pos by 2.\n\t\tif (pos >= 2 && candidate.charAt(pos - 2) === \"-\") {\n\t\t\tpos -= 2;\n\t\t}\n\n\t\t// Let candidate be the substring of candidate from position 0, inclusive, to position pos, exclusive.\n\t\tcandidate = candidate.slice(0, pos);\n\t}\n}\n","import {MatcherOptions} from \"../matcher-options\";\nimport {removeUnicodeExtensionSequences, UNICODE_EXTENSION_SEQUENCE_REGEXP} from \"../../unicode-extension/unicode-extension\";\nimport {bestAvailableLocale} from \"../best-available-locale/best-available-locale\";\nimport {MatcherResult} from \"../matcher-result\";\nimport {ensureDefaultLocale} from \"../../default-locale/get-default-locale\";\n\n/**\n * The LookupMatcher abstract operation compares requestedLocales, which must be a List as returned by CanonicalizeLocaleList,\n * against the locales in availableLocales and determines the best available language to meet the request.\n *\n * https://tc39.github.io/ecma402/#sec-lookupmatcher\n * @param {MatcherOptions} options\n * @return {MatcherResult}\n */\nexport function lookupMatcher({availableLocales, requestedLocales}: MatcherOptions): MatcherResult {\n\t// Let result be a new Record.\n\tconst result = {} as MatcherResult;\n\t// For each element locale of requestedLocales in List order, do\n\tfor (const locale of requestedLocales) {\n\t\t// Let noExtensionsLocale be the String value that is locale with all Unicode locale extension sequences removed.\n\t\tconst noExtensionsLocale = removeUnicodeExtensionSequences(locale);\n\n\t\t// Let availableLocale be BestAvailableLocale(availableLocales, noExtensionsLocale).\n\t\tconst availableLocale = bestAvailableLocale(availableLocales, noExtensionsLocale);\n\n\t\t// If availableLocale is not undefined, then\n\t\tif (availableLocale !== undefined) {\n\t\t\t// Set result.[[locale]] to availableLocale.\n\t\t\tresult.locale = availableLocale;\n\n\t\t\t// If locale and noExtensionsLocale are not the same String value, then\n\t\t\tif (locale !== noExtensionsLocale) {\n\t\t\t\t// Let extension be the String value consisting of the first substring of local\n\t\t\t\t// that is a Unicode locale extension sequence.\n\t\t\t\tconst extensionMatch = locale.match(UNICODE_EXTENSION_SEQUENCE_REGEXP);\n\t\t\t\t// Set result.[[extension]] to extension.\n\t\t\t\tresult.extension = extensionMatch == null ? \"\" : extensionMatch[0];\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\t// Let defLocale be DefaultLocale().\n\tconst defLocale = ensureDefaultLocale();\n\n\t// Set result.[[locale]] to defLocale.\n\tresult.locale = defLocale;\n\n\t// Return result.\n\treturn result;\n}\n","/**\n * Returns true if the given item is a record\n * @param {T} item\n * @return {item is T}\n */\nexport function isRecord<T>(item: T): item is Exclude<T, undefined> {\n\treturn Object.prototype.toString.call(item) === \"[object Object]\";\n}\n","/**\n * The internal comparison abstract operation SameValueNonNumber(x, y), where neither x nor y are Number values, produces true or false.\n *\n * https://tc39.github.io/ecma262/#sec-samevaluenonnumber\n * @param {Exclude<*, number>} x\n * @param {Exclude<*, number>} y\n * @return {boolean}\n */\nfunction sameValueNonNumber(x: Exclude<unknown, number>, y: Exclude<unknown, number>): boolean {\n\t// Assert: Type(x) is not Number.\n\tif (typeof x === \"number\") {\n\t\tthrow new TypeError(`First argument 'x' must not be a number`);\n\t}\n\n\t// Assert: Type(x) is the same as Type(y).\n\tif (typeof x !== typeof y) {\n\t\tthrow new TypeError(`The given arguments must have the same type`);\n\t}\n\n\t// If Type(x) is Undefined, return true.\n\tif (x === undefined) return true;\n\n\t// If Type(x) is Null, return true.\n\tif (x === null) return true;\n\n\t// If Type(x) is String, then\n\tif (typeof x === \"string\") {\n\t\t// If x and y are exactly the same sequence of code units\n\t\t// (same length and same code units at corresponding indices), return true; otherwise, return false.\n\t\treturn x === y;\n\t}\n\n\t// If Type(x) is Boolean, then\n\tif (typeof x === \"boolean\") {\n\t\t// If x and y are both true or both false, return true; otherwise, return false.\n\t\treturn x === y;\n\t}\n\n\t// If Type(x) is Symbol, then\n\tif (typeof x === \"symbol\") {\n\t\t// If x and y are both the same Symbol value, return true; otherwise, return false.\n\t\treturn x.valueOf() === (y as symbol).valueOf();\n\t}\n\n\t// If x and y are the same Object value, return true. Otherwise, return false.\n\treturn x === y;\n}\n\n/**\n * The internal comparison abstract operation SameValue(x, y), where x and y are ECMAScript language values, produces true or false.\n *\n * https://tc39.github.io/ecma262/#sec-samevalue\n * @param {*} x\n * @param {*} y\n * @return {boolean}\n */\nexport function sameValue(x: unknown, y: unknown): boolean {\n\t// If Type(x) is different from Type(y), return false.\n\tif (typeof x !== typeof y) return false;\n\n\t// If Type(x) is Number, then\n\tif (typeof x === \"number\") {\n\t\t// If x is NaN and y is NaN, return true.\n\t\tif (isNaN(x) && isNaN(y as number)) return true;\n\n\t\t// If x is +0 and y is -0, return false.\n\t\tif (Object.is(x, 0) && Object.is(y, -0)) return false;\n\n\t\t// If x is the same Number value as y, return true.\n\t\tif (x === y) return true;\n\n\t\t// Return false.\n\t\treturn false;\n\t}\n\t// Return SameValueNonNumber(x, y).\n\treturn sameValueNonNumber(x, y);\n}\n","import {ResolveLocaleOptions} from \"./resolve-locale-options\";\nimport {lookupMatcher} from \"../matcher/lookup-matcher/lookup-matcher\";\nimport {bestFitMatcher} from \"../matcher/best-fit-matcher/best-fit-matcher\";\nimport {ResolveLocaleResult} from \"./resolve-locale-result\";\nimport {isRecord} from \"../../assert/is-record\";\nimport {isList} from \"../../assert/is-list\";\nimport {unicodeExtensionValue} from \"../unicode-extension/unicode-extension\";\nimport {sameValue} from \"../../util/same-value\";\nimport {Locales} from \"../../locale/locales\";\nimport {RelevantExtensionKey} from \"../../relevant-extension-key/relevant-extension-key\";\nimport {LocaleData} from \"../../locale/locale-data\";\n\n/**\n * The ResolveLocale abstract operation compares a BCP 47 language priority list\n * requestedLocales against the locales in availableLocales and determines the best available language to meet the request.\n * availableLocales, requestedLocales, and relevantExtensionKeys must be provided as List values,\n * options and localeData as Records.\n *\n * https://tc39.github.io/ecma402/#sec-resolvelocale\n * @param {Locales} availableLocales\n * @param {Locales} requestedLocales\n * @param {ResolveLocaleOptions} options\n * @param {RelevantExtensionKey[]} relevantExtensionKeys\n * @param {LocaleData} localeData\n * @returns {ResolveLocaleResult}\n */\nexport function resolveLocale(\n\tavailableLocales: Locales,\n\trequestedLocales: Locales,\n\toptions: ResolveLocaleOptions,\n\trelevantExtensionKeys: RelevantExtensionKey[],\n\tlocaleData: LocaleData\n): ResolveLocaleResult {\n\t// Let matcher be options.[[localeMatcher]].\n\tconst matcher = options.localeMatcher;\n\t// If matcher is \"lookup\", then\n\t// (a) Let r be LookupMatcher(availableLocales, requestedLocales).\n\t// (b) Let r be BestFitMatcher(availableLocales, requestedLocales).\n\tconst r = matcher === \"lookup\" ? lookupMatcher({availableLocales, requestedLocales}) : bestFitMatcher({availableLocales, requestedLocales});\n\n\t// Let foundLocale be r.[[locale]].\n\tlet foundLocale = r.locale;\n\n\t// Let result be a new Record.\n\tconst result = {} as ResolveLocaleResult;\n\n\t// Set result.[[dataLocale]] to foundLocale.\n\tresult.dataLocale = foundLocale;\n\n\t// Let supportedExtension be \"-u\"\n\tlet supportedExtension = \"-u\";\n\n\t// For each element key of relevantExtensionKeys in List order, do\n\tfor (const key of relevantExtensionKeys) {\n\t\t// Let foundLocaleData be localeData.[[<foundLocale>]].\n\t\tconst foundLocaleData = localeData[foundLocale];\n\n\t\t// Assert: Type(foundLocaleData) is Record.\n\t\tif (!isRecord(foundLocaleData)) {\n\t\t\tthrow new TypeError(`LocaleData for locale: '${foundLocale}' must be an object`);\n\t\t}\n\n\t\t// Let keyLocaleData be foundLocaleData.[[<key>]].\n\t\tconst keyLocaleData = foundLocaleData[key];\n\n\t\t// Assert: Type(keyLocaleData) is List.\n\t\tif (!isList(keyLocaleData)) {\n\t\t\tthrow new TypeError(`key: '${key}' in LocaleData for locale: '${foundLocale}' must be indexable`);\n\t\t}\n\n\t\t// Let value be keyLocaleData[0].\n\t\tlet value = keyLocaleData[0];\n\n\t\t// Assert: Type(value) is either String or Null.\n\t\tif (typeof value !== \"string\" && value !== null) {\n\t\t\tthrow new TypeError(`value: '${value}' for key: '${key}' in LocaleData for locale: '${foundLocale}' must be a string or null`);\n\t\t}\n\n\t\t// Let supportedExtensionAddition be \"\".\n\t\tlet supportedExtensionAddition = \"\";\n\n\t\t// If r has an [[extension]] field, then\n\t\tif (\"extension\" in r) {\n\t\t\t// Let requestedValue be UnicodeExtensionValue(r.[[extension]], key).\n\t\t\tconst requestedValue = unicodeExtensionValue(r.extension!, key);\n\n\t\t\t// If requestedValue is not undefined, then\n\t\t\tif (requestedValue !== undefined) {\n\t\t\t\t// If requestedValue is not the empty String, then\n\t\t\t\tif (requestedValue !== \"\") {\n\t\t\t\t\t// If keyLocaleData contains requestedValue, then\n\t\t\t\t\tif (keyLocaleData.includes(requestedValue)) {\n\t\t\t\t\t\t// Let value be requestedValue.\n\t\t\t\t\t\tvalue = requestedValue;\n\n\t\t\t\t\t\t// Let supportedExtensionAddition be the concatenation of \"-\", key, \"-\", and value.\n\t\t\t\t\t\tsupportedExtensionAddition = `-${key}-${value}`;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Else if keyLocaleData contains \"true\", then\n\t\t\t\telse if (keyLocaleData.includes(\"true\")) {\n\t\t\t\t\t// Let value be \"true\".\n\t\t\t\t\tvalue = \"true\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If options has a field [[<key>]], then\n\t\tif (\"key\" in options) {\n\t\t\t// Let optionsValue be options.[[<key>]].\n\t\t\tconst optionsValue = options.key;\n\n\t\t\t// Assert: Type(optionsValue) is either String, Undefined, or Null.\n\t\t\tif (typeof optionsValue !== \"string\" && optionsValue != null) {\n\t\t\t\tthrow new TypeError(`options value: '${optionsValue}' must be a string, undefined, or null`);\n\t\t\t}\n\n\t\t\t// If keyLocaleData contains optionsValue, then\n\t\t\tif (optionsValue !== undefined && keyLocaleData.includes(optionsValue)) {\n\t\t\t\t// If SameValue(optionsValue, value) is false, then\n\t\t\t\t// tslint:disable-next-line:no-collapsible-if\n\t\t\t\tif (!sameValue(optionsValue, value)) {\n\t\t\t\t\t// Let value be optionsValue.\n\t\t\t\t\tvalue = optionsValue;\n\t\t\t\t\t// Let supportedExtensionAddition be \"\".\n\t\t\t\t\tsupportedExtensionAddition = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Set result.[[<key>]] to value.\n\t\tresult[key] = value;\n\n\t\t// Append supportedExtensionAddition to supportedExtension.\n\t\tsupportedExtension += supportedExtensionAddition;\n\t}\n\n\t// If the number of elements in supportedExtension is greater than 2, then\n\tif (supportedExtension.length > 2) {\n\t\t// Let privateIndex be Call(%StringProto_indexOf%, foundLocale, « \"-x-\" »).\n\t\tconst privateIndex = String.prototype.indexOf.call(foundLocale, \"-x-\");\n\n\t\t// If privateIndex = -1, then\n\t\tif (privateIndex === -1) {\n\t\t\t// Let foundLocale be the concatenation of foundLocale and supportedExtension.\n\t\t\tfoundLocale = `${foundLocale}${supportedExtension}`;\n\t\t}\n\n\t\t// Else,\n\t\telse {\n\t\t\t// Let preExtension be the substring of foundLocale from position 0, inclusive, to position privateIndex, exclusive.\n\t\t\tconst preExtension = foundLocale.slice(0, privateIndex);\n\n\t\t\t// Let postExtension be the substring of foundLocale from position privateIndex to the end of the string.\n\t\t\tconst postExtension = foundLocale.slice(privateIndex);\n\n\t\t\t// Let foundLocale be the concatenation of preExtension, supportedExtension, and postExtension.\n\t\t\tfoundLocale = `${preExtension}${supportedExtension}${postExtension}`;\n\t\t}\n\n\t\t// Assert: IsStructurallyValidLanguageTag(foundLocale) is true.\n\t\t// Let foundLocale be CanonicalizeLanguageTag(foundLocale).\n\t\t// Intl.getCanonicalLocales will throw a TypeError if the locale isn't structurally valid\n\t\tfoundLocale = Intl.getCanonicalLocales(foundLocale)[0];\n\t}\n\n\t// Set result.[[locale]] to foundLocale.\n\tresult.locale = foundLocale;\n\n\t// Return result.\n\treturn result;\n}\n","import {MatcherOptions} from \"../matcher-options\";\nimport {MatcherResult} from \"../matcher-result\";\nimport {lookupMatcher} from \"../lookup-matcher/lookup-matcher\";\n\n/**\n * The BestFitMatcher abstract operation compares requestedLocales,\n * which must be a List as returned by CanonicalizeLocaleList,\n * against the locales in availableLocales and determines the best available language to meet the request.\n * The algorithm is implementation dependent, but should produce results that a typical user of the requested\n * locales would perceive as at least as good as those produced by the LookupMatcher abstract operation.\n * RelativeTimeFormatOptions specified through Unicode locale extension sequences must be ignored by the algorithm.\n * Information about such subsequences is returned separately. The abstract operation returns a record\n * with a [[locale]] field, whose value is the language tag of the selected locale,\n * which must be an element of availableLocales.\n * If the language tag of the request locale that led to the selected locale contained a Unicode locale extension sequence,\n * then the returned record also contains an [[extension]] field whose value is the first Unicode locale extension sequence\n * within the request locale language tag.\n *\n * https://tc39.github.io/ecma402/#sec-bestfitmatcher\n * @param {MatcherOptions} options\n * @return {MatcherResult}\n */\nexport function bestFitMatcher(options: MatcherOptions): MatcherResult {\n\treturn lookupMatcher(options);\n}\n","import {isRecord} from \"./is-record\";\nimport {List} from \"../list/list\";\n\n/**\n * Returns true if the given item is a List\n * @param {T} item\n * @return {item is T}\n */\nexport function isList<T>(item: unknown): item is List<T> {\n\treturn Array.isArray(item) || isRecord(item);\n}\n","import {Locales} from \"../../locale/locales\";\nimport {removeUnicodeExtensionSequences} from \"../unicode-extension/unicode-extension\";\nimport {bestAvailableLocale} from \"../matcher/best-available-locale/best-available-locale\";\n\n/**\n * The LookupSupportedLocales abstract operation returns the subset of the provided BCP 47 language priority list\n * requestedLocales for which availableLocales has a matching locale when using the BCP 47 Lookup algorithm.\n * Locales appear in the same order in the returned list as in requestedLocales.\n *\n * https://tc39.github.io/ecma402/#sec-bestfitsupportedlocales\n * @param {Locales} availableLocales\n * @param {Locales} requestedLocales\n * @return {Locales}\n */\nexport function lookupSupportedLocales(availableLocales: Locales, requestedLocales: Locales): Locales {\n\t// Let subset be a new empty List.\n\tconst subset: Locales = [];\n\t// For each element locale of requestedLocales in List order, do\n\tfor (const locale of requestedLocales) {\n\t\t// Let noExtensionsLocale be the String value that is locale with all Unicode locale extension sequences removed.\n\t\tconst noExtensionsLocale = removeUnicodeExtensionSequences(locale);\n\n\t\t// Let availableLocale be BestAvailableLocale(availableLocales, noExtensionsLocale).\n\t\tconst availableLocale = bestAvailableLocale(availableLocales, noExtensionsLocale);\n\n\t\t// If availableLocale is not undefined, append locale to the end of subset.\n\t\tif (availableLocale !== undefined) {\n\t\t\tsubset.push(locale);\n\t\t}\n\t}\n\treturn subset;\n}\n","import {Locales} from \"../../locale/locales\";\nimport {toObject} from \"../../util/to-object\";\nimport {bestFitSupportedLocales} from \"./best-fit-supported-locales\";\nimport {lookupSupportedLocales} from \"./lookup-supported-locales\";\nimport {SupportedLocalesOptions} from \"./supported-locales-options\";\n\n/**\n * The SupportedLocales abstract operation returns the subset of the provided BCP 47 language priority list\n * requestedLocales for which availableLocales has a matching locale. Two algorithms are available to match\n * the locales: the Lookup algorithm described in RFC 4647 section 3.4, and an implementation dependent\n * best-fit algorithm. Locales appear in the same order in the returned list as in requestedLocales.\n *\n * https://tc39.github.io/ecma402/#sec-supportedlocales\n * @param {Locales} availableLocales\n * @param {Locales} requestedLocales\n * @param {SupportedLocalesOptions} [options]\n * @return {Locales}\n */\nexport function supportedLocales(availableLocales: Locales, requestedLocales: Locales, options?: SupportedLocalesOptions): Locales {\n\t// If options is not undefined, then\n\tif (options !== undefined) {\n\t\t// Let options be ? ToObject(options).\n\t\toptions = toObject(options);\n\t}\n\n\t// If options is not undefined, then Let matcher be ? GetOption(options, \"localeMatcher\", \"string\", « \"lookup\", \"best fit\" »,  \"best fit\").\n\t// Else, let matcher be \"best fit\".\n\tconst matcher = options !== undefined && options.localeMatcher != null ? options.localeMatcher : \"best fit\";\n\n\t// If matcher is \"best fit\", then let supportedLocales be BestFitSupportedLocales(availableLocales, requestedLocales).\n\t// Else let supportedLocales be LookupSupportedLocales(availableLocales, requestedLocales).\n\t// Return CreateArrayFromList(supportedLocales).\n\treturn matcher === \"best fit\" ? bestFitSupportedLocales(availableLocales, requestedLocales) : lookupSupportedLocales(availableLocales, requestedLocales);\n}\n","import {Locales} from \"../../locale/locales\";\nimport {lookupSupportedLocales} from \"./lookup-supported-locales\";\n\n/**\n * The BestFitSupportedLocales abstract operation returns the subset of the provided BCP 47 language priority list\n * requestedLocales for which availableLocales has a matching locale when using the Best Fit Matcher algorithm.\n * Locales appear in the same order in the returned list as in requestedLocales.\n *\n * https://tc39.github.io/ecma402/#sec-bestfitsupportedlocales\n * @param {Locales} availableLocales\n * @param {Locales} requestedLocales\n * @return {Locales}\n */\nexport function bestFitSupportedLocales(availableLocales: Locales, requestedLocales: Locales): Locales {\n\treturn lookupSupportedLocales(availableLocales, requestedLocales);\n}\n","import {RelativeTimeFormat} from \"../relative-time-format/relative-time-format\";\nimport {RelativeTimeFormatInstanceInternals} from \"./relative-time-format-instance-internals\";\nimport {RelativeTimeFormatStaticInternals} from \"./relative-time-format-static-internals\";\n\n/**\n * A WeakMap between RelativeTimeFormat instances and their internal slot members\n * @type {WeakMap<RelativeTimeFormat, RelativeTimeFormatInstanceInternals>}\n */\nexport const RELATIVE_TIME_FORMAT_INSTANCE_INTERNAL_MAP: WeakMap<RelativeTimeFormat, RelativeTimeFormatInstanceInternals> = new WeakMap();\n\n/**\n * Contains the internal static for RelativeTimeFormat\n * @type {RelativeTimeFormatStaticInternals}\n */\nexport const RELATIVE_TIME_FORMAT_STATIC_INTERNALS: RelativeTimeFormatStaticInternals = {\n\t/**\n\t * The value of the [[RelevantExtensionKeys]] internal slot is « \"nu\" ».\n\t * http://tc39.github.io/proposal-intl-relative-time/#sec-Intl.RelativeTimeFormat-internal-slots\n\t */\n\trelevantExtensionKeys: [\"nu\"],\n\n\t/**\n\t * The value of the [[LocaleData]] internal slot is implementation defined within the constraints described in 9.1\n\t * http://tc39.github.io/proposal-intl-relative-time/#sec-Intl.RelativeTimeFormat-internal-slots\n\t */\n\tlocaleData: {},\n\n\t/**\n\t * The value of the [[AvailableLocales]] internal slot is implementation defined within the constraints described in 9.1\n\t * http://tc39.github.io/proposal-intl-relative-time/#sec-Intl.RelativeTimeFormat-internal-slots\n\t */\n\tavailableLocales: []\n};\n\n/**\n * Sets the value for a property in an internal slot for an instance of RelativeTimeFormat\n * @param {RelativeTimeFormat} instance\n * @param {T} property\n * @param {RelativeTimeFormatInstanceInternals[T]} value\n */\nexport function setInternalSlot<T extends keyof RelativeTimeFormatInstanceInternals>(instance: RelativeTimeFormat, property: T, value: RelativeTimeFormatInstanceInternals[T]): void {\n\tlet record = RELATIVE_TIME_FORMAT_INSTANCE_INTERNAL_MAP.get(instance);\n\tif (record == null) {\n\t\trecord = {} as RelativeTimeFormatInstanceInternals;\n\t\tRELATIVE_TIME_FORMAT_INSTANCE_INTERNAL_MAP.set(instance, record);\n\t}\n\n\t// Update the property with the given value\n\trecord[property] = value;\n}\n\n/**\n * Gets the value associated with the given property on the internal slots of the given instance of RelativeTimeFormat\n * @param {RelativeTimeFormat} instance\n * @param {T} property\n * @return {RelativeTimeFormatInstanceInternals[T]}\n */\nexport function getInternalSlot<T extends keyof RelativeTimeFormatInstanceInternals>(instance: RelativeTimeFormat, property: T): RelativeTimeFormatInstanceInternals[T] {\n\tconst record = RELATIVE_TIME_FORMAT_INSTANCE_INTERNAL_MAP.get(instance);\n\tif (record == null) {\n\t\tthrow new ReferenceError(`No internal slots has been allocated for the given instance of RelativeTimeFormat`);\n\t}\n\n\treturn record[property];\n}\n\n/**\n * Returns true if the given property on the internal slots of the given instance of RelativeTimeFormat exists\n * @param {RelativeTimeFormat} instance\n * @param {T} property\n * @return {RelativeTimeFormatInstanceInternals[T]}\n */\nexport function hasInternalSlot<T extends keyof RelativeTimeFormatInstanceInternals>(instance: RelativeTimeFormat, property: T): boolean {\n\tconst record = RELATIVE_TIME_FORMAT_INSTANCE_INTERNAL_MAP.get(instance);\n\treturn record != null && property in record;\n}\n","export const NUMBERING_SYSTEMS: Record<string, string[]> = {\n\tarab: [\"\\u0660\", \"\\u0661\", \"\\u0662\", \"\\u0663\", \"\\u0664\", \"\\u0665\", \"\\u0666\", \"\\u0667\", \"\\u0668\", \"\\u0669\"],\n\tarabext: [\"\\u06F0\", \"\\u06F1\", \"\\u06F2\", \"\\u06F3\", \"\\u06F4\", \"\\u06F5\", \"\\u06F6\", \"\\u06F7\", \"\\u06F8\", \"\\u06F9\"],\n\tbali: [\"\\u1B50\", \"\\u1B51\", \"\\u1B52\", \"\\u1B53\", \"\\u1B54\", \"\\u1B55\", \"\\u1B56\", \"\\u1B57\", \"\\u1B58\", \"\\u1B59\"],\n\tbeng: [\"\\u09E6\", \"\\u09E7\", \"\\u09E8\", \"\\u09E9\", \"\\u09EA\", \"\\u09EB\", \"\\u09EC\", \"\\u09ED\", \"\\u09EE\", \"\\u09EF\"],\n\tdeva: [\"\\u0966\", \"\\u0967\", \"\\u0968\", \"\\u0969\", \"\\u096A\", \"\\u096B\", \"\\u096C\", \"\\u096D\", \"\\u096E\", \"\\u096F\"],\n\tfullwide: [\"\\uFF10\", \"\\uFF11\", \"\\uFF12\", \"\\uFF13\", \"\\uFF14\", \"\\uFF15\", \"\\uFF16\", \"\\uFF17\", \"\\uFF18\", \"\\uFF19\"],\n\tgujr: [\"\\u0AE6\", \"\\u0AE7\", \"\\u0AE8\", \"\\u0AE9\", \"\\u0AEA\", \"\\u0AEB\", \"\\u0AEC\", \"\\u0AED\", \"\\u0AEE\", \"\\u0AEF\"],\n\tguru: [\"\\u0A66\", \"\\u0A67\", \"\\u0A68\", \"\\u0A69\", \"\\u0A6A\", \"\\u0A6B\", \"\\u0A6C\", \"\\u0A6D\", \"\\u0A6E\", \"\\u0A6F\"],\n\thanidec: [\"\\u3007\", \"\\u4E00\", \"\\u4E8C\", \"\\u4E09\", \"\\u56DB\", \"\\u4E94\", \"\\u516D\", \"\\u4E03\", \"\\u516B\", \"\\u4E5D\"],\n\tkhmr: [\"\\u17E0\", \"\\u17E1\", \"\\u17E2\", \"\\u17E3\", \"\\u17E4\", \"\\u17E5\", \"\\u17E6\", \"\\u17E7\", \"\\u17E8\", \"\\u17E9\"],\n\tknda: [\"\\u0CE6\", \"\\u0CE7\", \"\\u0CE8\", \"\\u0CE9\", \"\\u0CEA\", \"\\u0CEB\", \"\\u0CEC\", \"\\u0CED\", \"\\u0CEE\", \"\\u0CEF\"],\n\tlaoo: [\"\\u0ED0\", \"\\u0ED1\", \"\\u0ED2\", \"\\u0ED3\", \"\\u0ED4\", \"\\u0ED5\", \"\\u0ED6\", \"\\u0ED7\", \"\\u0ED8\", \"\\u0ED9\"],\n\tlatn: [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"],\n\tlimb: [\"\\u1946\", \"\\u1947\", \"\\u1948\", \"\\u1949\", \"\\u194A\", \"\\u194B\", \"\\u194C\", \"\\u194D\", \"\\u194E\", \"\\u194F\"],\n\tmlym: [\"\\u0D66\", \"\\u0D67\", \"\\u0D68\", \"\\u0D69\", \"\\u0D6A\", \"\\u0D6B\", \"\\u0D6C\", \"\\u0D6D\", \"\\u0D6E\", \"\\u0D6F\"],\n\tmong: [\"\\u1810\", \"\\u1811\", \"\\u1812\", \"\\u1813\", \"\\u1814\", \"\\u1815\", \"\\u1816\", \"\\u1817\", \"\\u1818\", \"\\u1819\"],\n\tmymr: [\"\\u1040\", \"\\u1041\", \"\\u1042\", \"\\u1043\", \"\\u1044\", \"\\u1045\", \"\\u1046\", \"\\u1047\", \"\\u1048\", \"\\u1049\"],\n\torya: [\"\\u0B66\", \"\\u0B67\", \"\\u0B68\", \"\\u0B69\", \"\\u0B6A\", \"\\u0B6B\", \"\\u0B6C\", \"\\u0B6D\", \"\\u0B6E\", \"\\u0B6F\"],\n\ttamldec: [\"\\u0BE6\", \"\\u0BE7\", \"\\u0BE8\", \"\\u0BE9\", \"\\u0BEA\", \"\\u0BEB\", \"\\u0BEC\", \"\\u0BED\", \"\\u0BEE\", \"\\u0BEF\"],\n\ttelu: [\"\\u0C66\", \"\\u0C67\", \"\\u0C68\", \"\\u0C69\", \"\\u0C6A\", \"\\u0C6B\", \"\\u0C6C\", \"\\u0C6D\", \"\\u0C6E\", \"\\u0C6F\"],\n\tthai: [\"\\u0E50\", \"\\u0E51\", \"\\u0E52\", \"\\u0E53\", \"\\u0E54\", \"\\u0E55\", \"\\u0E56\", \"\\u0E57\", \"\\u0E58\", \"\\u0E59\"],\n\ttibt: [\"\\u0F20\", \"\\u0F21\", \"\\u0F22\", \"\\u0F23\", \"\\u0F24\", \"\\u0F25\", \"\\u0F26\", \"\\u0F27\", \"\\u0F28\", \"\\u0F29\"]\n};\n","import {RelativeTimeFormat} from \"../relative-time-format/relative-time-format\";\nimport {RelativeTimeUnit} from \"../../unit/relative-time-unit\";\nimport {ExtendedSingularRelativeTimeUnit, singularRelativeTimeUnit} from \"../../unit/singular-relative-time-unit\";\nimport {UnitPartitions} from \"../../partition/partition\";\nimport {partitionNumberPattern} from \"../partition-number-pattern/partition-number-pattern\";\nimport {getInternalSlot, hasInternalSlot} from \"../internal-slot/internal-slot\";\nimport {resolvePlural} from \"../resolve-plural/resolve-plural\";\nimport {makePartsList} from \"../make-parts-list/make-parts-list\";\n\n/**\n * When the FormatRelativeTime abstract operation is called with arguments relativeTimeFormat,\n * value, and unit it returns a String value representing value (interpreted as a time value as specified in ES2016, 20.3.1.1)\n * according to the effective locale and the formatting options of relativeTimeFormat.\n * @param {RelativeTimeFormat} relativeTimeFormat\n * @param {number} value\n * @param {RelativeTimeUnit} unit\n * @returns {UnitPartitions}\n */\nexport function partitionRelativeTimePattern(relativeTimeFormat: RelativeTimeFormat, value: number, unit: RelativeTimeUnit): UnitPartitions {\n\t// Assert: relativeTimeFormat has an [[InitializedRelativeTimeFormat]] internal slot.\n\tif (!hasInternalSlot(relativeTimeFormat, \"initializedRelativeTimeFormat\")) {\n\t\tthrow new TypeError(`Internal function called on incompatible receiver ${relativeTimeFormat.toString()}`);\n\t}\n\n\t// Assert: Type(value) is Number.\n\tif (typeof value !== \"number\") {\n\t\tthrow new TypeError(`Argument: 'value' must be a number`);\n\t}\n\t// Assert: Type(unit) is String.\n\tif (typeof unit !== \"string\") {\n\t\tthrow new TypeError(`Argument: 'unit' must be a string`);\n\t}\n\n\t// If value is NaN, +∞, or -∞, throw a RangeError exception.\n\tif (isNaN(value) || value === Infinity || value === -Infinity) {\n\t\tthrow new RangeError(`Value need to be finite number`);\n\t}\n\n\t// Let unit be ? SingularRelativeTimeUnit(unit).\n\tunit = singularRelativeTimeUnit(unit);\n\n\t// Let fields be relativeTimeFormat.[[Fields]].\n\tconst fields = getInternalSlot(relativeTimeFormat, \"fields\");\n\n\t// Let style be relativeTimeFormat.[[Style]].\n\tconst style = getInternalSlot(relativeTimeFormat, \"style\");\n\n\t// If style is equal to \"short\", then let entry be the string-concatenation of unit and \"-short\".\n\t// Else if style is equal to \"narrow\", then let entry be the string-concatenation of unit and \"-narrow\".\n\t// Else let entry be unit.\n\tlet entry = style === \"short\" ? (`${unit}-short` as ExtendedSingularRelativeTimeUnit) : style === \"narrow\" ? (`${unit}-narrow` as ExtendedSingularRelativeTimeUnit) : unit;\n\n\t// Let exists be ! HasProperty(fields, entry).\n\tlet exists = entry in fields;\n\n\t// If exists is false, then\n\tif (!exists) {\n\t\t// Let entry be unit.\n\t\tentry = unit;\n\t}\n\n\t// Let patterns be ! Get(fields, entry).\n\tconst patterns = fields[entry];\n\n\t// Make sure that the patterns are defined\n\tif (patterns == null) {\n\t\tthrow new TypeError(`Could not match entry: '${entry}' inside fields for locale: '${getInternalSlot(relativeTimeFormat, \"locale\")}'`);\n\t}\n\n\t// Let numeric be relativeTimeFormat.[[Numeric]].\n\tconst numeric = getInternalSlot(relativeTimeFormat, \"numeric\");\n\n\t// If numeric is equal to \"auto\", then\n\tif (numeric === \"auto\") {\n\t\t// Let exists be ! HasProperty(patterns, ! ToString(value)).\n\t\texists = String(value) in patterns;\n\n\t\t// If exists is true, then\n\t\tif (exists) {\n\t\t\t// Let result be ! Get(patterns, ! ToString(value)).\n\t\t\tconst result = patterns[String(value)];\n\n\t\t\t// Return a List containing the Record { [[Type]]: \"literal\", [[Value]]: result }.\n\t\t\treturn [\n\t\t\t\t{\n\t\t\t\t\ttype: \"literal\",\n\t\t\t\t\tvalue: result\n\t\t\t\t}\n\t\t\t];\n\t\t}\n\t}\n\n\t// If value is -0 or if value is less than 0, then let tl be \"past\".\n\t// Else let tl be \"future\".\n\tconst tl = Object.is(value, -0) || value < 0 ? \"past\" : \"future\";\n\n\t// Let po be ! Get(patterns, tl).\n\tconst po = patterns[tl];\n\n\t// Let fv be ! PartitionNumberPattern(relativeTimeFormat.[[NumberFormat]], value).\n\tconst fv = partitionNumberPattern(relativeTimeFormat, value);\n\n\t// Let pr be ! ResolvePlural(relativeTimeFormat.[[PluralRules]], value).\n\tconst pr = resolvePlural(relativeTimeFormat, value);\n\n\t// Let pattern be ! Get(po, pr).\n\tconst pattern = po[pr];\n\n\t// Return ! MakePartsList(pattern, unit, fv).\n\treturn makePartsList(pattern, unit, fv);\n}\n","import {Partition, Partitions} from \"../../partition/partition\";\nimport {RelativeTimeFormat} from \"../relative-time-format/relative-time-format\";\nimport {getInternalSlot} from \"../internal-slot/internal-slot\";\nimport {NUMBERING_SYSTEMS} from \"../numbering-systems/numbering-systems\";\n\n/**\n * The PartitionNumberPattern abstract operation is called with arguments numberFormat\n * (which must be an object initialized as a NumberFormat) and x (which must be a Number value),\n * interprets x as a numeric value, and creates the corresponding parts according to the effective locale\n * and the formatting options of numberFormat.\n * @param {RelativeTimeFormat} relativeTimeFormat - needed to get internal slots\n * @param {number} x\n * @returns {Partitions}\n */\nexport function partitionNumberPattern(relativeTimeFormat: RelativeTimeFormat, x: number): Partitions {\n\tlet pattern: string;\n\tconst locale = getInternalSlot(relativeTimeFormat, \"locale\");\n\tconst numberFormat = getInternalSlot(relativeTimeFormat, \"numberFormat\");\n\tconst {numberingSystem} = relativeTimeFormat.resolvedOptions();\n\n\t// If x is not NaN and x < 0 or x is -0, then\n\tif (!isNaN(x) && (x < 0 || Object.is(x, -0))) {\n\t\t// Let x be -x.\n\t\tx = -x;\n\t\t// Let pattern be numberFormat.[[NegativePattern]].\n\t\t// Since we don't have access to the internal slots, take it from the locale data\n\t\t// CORRECTION: The positive pattern should always be used when formatting relative time\n\t\t// TODO: Since we don't care about positive and negative patterns, can we leave out the pattern data all-together from this polyfill?\n\t\tpattern = \"{number}\";\n\t}\n\n\t// Else,\n\telse {\n\t\t// Let pattern be numberFormat.[[PositivePattern]].\n\t\t// Since we don't have access to the internal slots, take it from the locale data\n\t\t// TODO: Since we don't care about positive and negative patterns, can we leave out the pattern data all-together from this polyfill?\n\t\tpattern = \"{number}\";\n\t}\n\n\t// Let result be a new empty List.\n\tconst result: Partition[] = [];\n\n\t// Let beginIndex be Call(%StringProto_indexOf%, pattern, « \"{\", 0 »).\n\tlet beginIndex = String.prototype.indexOf.call(pattern, \"{\", 0);\n\n\t// Let endIndex be 0.\n\tlet endIndex = 0;\n\n\t// Let nextIndex be 0.\n\tlet nextIndex = 0;\n\n\t// Let length be the number of code units in pattern.\n\tconst length = pattern.length;\n\n\t// Repeat, while beginIndex is an integer index into pattern\n\twhile (pattern[beginIndex] !== undefined) {\n\t\t// Set endIndex to Call(%StringProto_indexOf%, pattern, « \"}\", beginIndex »).\n\t\tendIndex = String.prototype.indexOf.call(pattern, \"}\", beginIndex);\n\n\t\t// Assert: endIndex is greater than beginIndex.\n\t\tif (endIndex <= beginIndex) {\n\t\t\tthrow new TypeError(`endIndex: ${endIndex} must be greater than beginIndex: ${beginIndex}`);\n\t\t}\n\n\t\t// If beginIndex is greater than nextIndex, then\n\t\tif (beginIndex > nextIndex) {\n\t\t\t// Let literal be a substring of pattern from position nextIndex, inclusive, to position beginIndex, exclusive.\n\t\t\tconst literal = pattern.slice(nextIndex, beginIndex);\n\n\t\t\t// Append a new Record { [[Type]]: \"literal\", [[Value]]: literal } as the last element of result.\n\t\t\tresult.push({\n\t\t\t\ttype: \"literal\",\n\t\t\t\tvalue: literal\n\t\t\t});\n\t\t}\n\n\t\t// CORRECTION FOR RelativeTimeFormat: p will always be equal to 'number'\n\t\t// CORRECTION FOR RelativeTimeFormat: p will always be finite, so we don't have to check for NaN and isFinite\n\t\t// CORRECTION FOR RelativeTimeFormat: NumberFormat.[[Style]] will always be \"decimal\"\n\t\t// CORRECTION FOR RelativeTimeFormat: NumberFormat.[[UseGrouping]] will always be false\n\t\t// CORRECTION FOR RelativeTimeFormat: Even though the spec doesn't explicitly state it, existing implementations such as in Chrome groups floats with decimals into integers. For example, 1.1 becomes {type: \"integer\", value: \"1.1\"}\n\n\t\t// Let n be FormatNumberToString(numberFormat, x).\n\t\tlet n = x.toLocaleString(locale, numberFormat.resolvedOptions());\n\n\t\t// If the numberFormat.[[NumberingSystem]] matches one of the values in the\n\t\t// \"Numbering System\" column of Table 3 (https://tc39.github.io/ecma402/#table-numbering-system-digits), then\n\t\tif (NUMBERING_SYSTEMS[numberingSystem] != null) {\n\t\t\t// Let digits be a List whose 10 String valued elements are the UTF-16 string representations of the 10 digits specified in the \"Digits\" column of the matching row in Table 3.\n\t\t\tconst digits = [...NUMBERING_SYSTEMS[numberingSystem]];\n\n\t\t\t// Replace each digit in n with the value of digits[digit].\n\t\t\tn = n.replace(/\\d/g, digit => digits[(digit as unknown) as number]);\n\t\t}\n\n\t\t// Else use an implementation dependent algorithm to map n to the appropriate\n\t\t// representation of n in the given numbering system.\n\t\telse {\n\t\t\tn = String(n);\n\t\t}\n\n\t\tconst integer: string = n;\n\n\t\t// Append a new Record { [[Type]]: \"integer\", [[Value]]: integer } as the last element of result.\n\t\tresult.push({\n\t\t\ttype: \"integer\",\n\t\t\tvalue: integer\n\t\t});\n\n\t\t// Set nextIndex to endIndex + 1.\n\t\tnextIndex = endIndex + 1;\n\n\t\t// Set beginIndex to Call(%StringProto_indexOf%, pattern, « \"{\", nextIndex »).\n\t\tbeginIndex = String.prototype.indexOf.call(pattern, \"{\", nextIndex);\n\t}\n\n\t// If nextIndex is less than length, then\n\tif (nextIndex < length) {\n\t\t// Let literal be the substring of pattern from position nextIndex, inclusive, to position length, exclusive.\n\t\tconst literal = pattern.slice(nextIndex, length);\n\n\t\t// Append a new Record { [[Type]]: \"literal\", [[Value]]: literal } as the last element of result.\n\t\tresult.push({\n\t\t\ttype: \"literal\",\n\t\t\tvalue: literal\n\t\t});\n\t}\n\n\t// Return result.\n\treturn result;\n}\n","import {SingularRelativeTimeUnit} from \"../../unit/singular-relative-time-unit\";\nimport {Partitions, UnitPartition, UnitPartitions} from \"../../partition/partition\";\n\n/**\n * The MakePartsList abstract operation is called with arguments pattern,\n * a pattern String, unit, a String, and parts, a List of Records representing a formatted Number.\n *\n * http://tc39.github.io/proposal-intl-relative-time/#sec-makepartslist\n * @param {string} pattern\n * @param {SingularRelativeTimeUnit} unit\n * @param {Partitions} parts\n * @returns {UnitPartitions}\n */\nexport function makePartsList(pattern: string, unit: SingularRelativeTimeUnit, parts: Partitions): UnitPartitions {\n\t// Let result be a new empty List.\n\tconst result: UnitPartition[] = [];\n\n\t// Let beginIndex be ! Call(%StringProto_indexOf%, pattern, « \"{\", 0 »).\n\tlet beginIndex = String.prototype.indexOf.call(pattern, \"{\", 0);\n\n\t// Let endIndex be 0.\n\tlet endIndex = 0;\n\n\t// Let nextIndex be 0.\n\tlet nextIndex = 0;\n\n\t// Let length be the number of elements in pattern.\n\tconst length = pattern.length;\n\n\t// Repeat, while beginIndex is an integer index into pattern\n\twhile (pattern[beginIndex] !== undefined) {\n\t\t// Set endIndex to ! Call(%StringProto_indexOf%, pattern, « \"}\", beginIndex »).\n\t\tendIndex = String.prototype.indexOf.call(pattern, \"}\", beginIndex);\n\n\t\t// Assert: endIndex is not -1, otherwise the pattern would be malformed.\n\t\tif (endIndex === -1) {\n\t\t\tthrow new RangeError(`The pattern: '${pattern}' is malformed`);\n\t\t}\n\n\t\t// If beginIndex is greater than nextIndex, then\n\t\tif (beginIndex > nextIndex) {\n\t\t\t// Let literal be a substring of pattern from position nextIndex, inclusive, to position beginIndex, exclusive.\n\t\t\tconst literal = pattern.slice(nextIndex, beginIndex);\n\n\t\t\t// Add new part Record { [[Type]]: \"literal\", [[Value]]: literal } as a new element of the list result.\n\t\t\tresult.push({\n\t\t\t\ttype: \"literal\",\n\t\t\t\tvalue: literal\n\t\t\t});\n\t\t}\n\n\t\t// Let p be the substring of pattern from position beginIndex, exclusive, to position endIndex, exclusive.\n\t\tconst p = pattern.slice(beginIndex + 1, endIndex);\n\n\t\t// Assert: p is \"0\".\n\t\tif (p !== \"0\") {\n\t\t\tthrow new TypeError(`Expected ${p} to be \"0\"`);\n\t\t}\n\n\t\t// For each part in parts, do\n\t\tfor (const part of parts) {\n\t\t\t// Add new part Record { [[Type]]: part.[[Type]], [[Value]]: part.[[Value]], [[Unit]]: unit } as a new element on the List result.\n\t\t\tif (part.type === \"literal\") {\n\t\t\t\tresult.push({...part});\n\t\t\t} else {\n\t\t\t\tresult.push({...part, unit});\n\t\t\t}\n\t\t}\n\n\t\t// Set nextIndex to endIndex + 1.\n\t\tnextIndex = endIndex + 1;\n\n\t\t// Set beginIndex to Call(%StringProto_indexOf%, pattern, « \"{\", nextIndex »).\n\t\tbeginIndex = String.prototype.indexOf.call(pattern, \"{\", nextIndex);\n\t}\n\n\t// If nextIndex is less than length, then\n\tif (nextIndex < length) {\n\t\t// Let literal be the substring of pattern from position nextIndex, exclusive, to position length, exclusive.\n\t\t// CORRECTION: It should actually be from nextIndex, inclusive, to correctly partition text\n\t\tconst literal = pattern.slice(nextIndex, length);\n\n\t\t// Add new part Record { [[Type]]: \"literal\", [[Value]]: literal } as a new element of the list result.\n\t\tresult.push({\n\t\t\ttype: \"literal\",\n\t\t\tvalue: literal\n\t\t});\n\t}\n\n\treturn result;\n}\n","import {RelativeTimeFormat} from \"../relative-time-format/relative-time-format\";\nimport {getInternalSlot, hasInternalSlot} from \"../internal-slot/internal-slot\";\n\n/**\n * When the ResolvePlural abstract operation is called with arguments pluralRules (which must be an object initialized as a PluralRules) and n (which must be a Number value), it returns a String value representing the plural form of n according to the effective locale and the options of pluralRules.\n *\n * https://tc39.github.io/ecma402/#sec-resolveplural\n * @param {RelativeTimeFormat} relativeTimeFormat - needed to get internal slots\n * @param {number} n\n */\nexport function resolvePlural(relativeTimeFormat: RelativeTimeFormat, n: number): string {\n\t// Assert: Type(pluralRules) is Object.\n\t// Assert: pluralRules has an [[InitializedPluralRules]] internal slot.\n\tif (!hasInternalSlot(relativeTimeFormat, \"pluralRules\")) {\n\t\tthrow new TypeError(`Given instance of of Intl.RelativeTimeFormat must have an [[InitializedPluralRules]] internal slot`);\n\t}\n\n\t// Assert: Type(n) is Number.\n\tif (typeof n !== \"number\") {\n\t\tthrow new TypeError(`Argument 'n' must be a number`);\n\t}\n\n\t// If n is not a finite Number, then\n\tif (!isFinite(n)) {\n\t\t// Return \"other\".\n\t\treturn \"other\";\n\t}\n\n\t// Let locale be pluralRules.[[Locale]].\n\t// Let type be pluralRules.[[Type]].\n\tconst pluralRules = getInternalSlot(relativeTimeFormat, \"pluralRules\");\n\n\t// Return ? PluralRuleSelect(locale, type, n, operands).\n\treturn pluralRules.select(n);\n}\n","import {Locale} from \"../../locale/locale\";\nimport {Locales} from \"../../locale/locales\";\nimport {RelativeTimeFormatOptions} from \"./relative-time-format-options\";\nimport {toObject} from \"../../util/to-object\";\nimport {InputLocaleDataEntry} from \"../../locale/locale-data\";\nimport {resolveLocale} from \"../resolve-locale/resolve-locale\";\nimport {supportedLocales} from \"../supported-locales/supported-locales\";\nimport {SupportedLocalesOptions} from \"../supported-locales/supported-locales-options\";\nimport {RelativeTimeUnit} from \"../../unit/relative-time-unit\";\nimport {formatRelativeTime} from \"../format-relative-time/format-relative-time\";\nimport {getInternalSlot, hasInternalSlot, RELATIVE_TIME_FORMAT_STATIC_INTERNALS, setInternalSlot} from \"../internal-slot/internal-slot\";\nimport {IntlPluralRulesConstructor} from \"../../intl-object/intl-object\";\nimport {UnitPartitions} from \"../../partition/partition\";\nimport {formatRelativeTimeToParts} from \"../format-relative-time-to-parts/format-relative-time-to-parts\";\nimport {ResolvedRelativeTimeFormatOptions} from \"./resolved-relative-time-format-options\";\nimport {getDefaultLocale, setDefaultLocale} from \"../default-locale/get-default-locale\";\n\n/**\n * The RelativeTimeFormat constructor is the %RelativeTimeFormat% intrinsic object and a standard built-in property of the Intl object.\n * Behaviour common to all service constructor properties of the Intl object is specified in 9.1.\n *\n * http://tc39.github.io/proposal-intl-relative-time/#sec-intl-relativetimeformat-constructor\n */\nexport class RelativeTimeFormat {\n\t/**\n\t * The initial value of the @@toStringTag property is the string value \"Intl.RelativeTimeFormat\".\n\t * This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.\n\t * @type {string}\n\t */\n\tpublic [Symbol.toStringTag] = \"Intl.RelativeTimeFormat\";\n\n\tconstructor(locales?: Locale | Locales | undefined, options?: Partial<RelativeTimeFormatOptions>) {\n\t\t// If NewTarget is undefined, throw a TypeError exception.\n\t\tif (new.target === undefined) {\n\t\t\tthrow new TypeError(`Constructor Intl.RelativeTimeFormat requires 'new'`);\n\t\t}\n\n\t\t// The following operations comes from the 'InitializeRelativeFormat' abstract operation (http://tc39.github.io/proposal-intl-relative-time/#sec-InitializeRelativeTimeFormat)\n\t\t// Let requestedLocales be ? CanonicalizeLocaleList(locales).\n\t\tconst requestedLocales = Intl.getCanonicalLocales(locales);\n\n\t\t// If options is undefined, then (a) Let options be ObjectCreate(null).\n\t\t// Else (b) Let options be ? ToObject(options).\n\t\toptions = options === undefined ? (Object.create(null) as Partial<RelativeTimeFormatOptions>) : toObject(options);\n\n\t\t// Let opt be a new Record.\n\t\tconst opt = {} as RelativeTimeFormatOptions;\n\n\t\t// Let matcher be ? GetOption(options, \"localeMatcher\", \"string\", «\"lookup\", \"best fit\"»,  \"best fit\").\n\t\tconst matcher = options.localeMatcher != null ? options.localeMatcher : \"best fit\";\n\n\t\t// Set opt.[[LocaleMatcher]] to matcher.\n\t\topt.localeMatcher = matcher;\n\n\t\t// Let localeData be %RelativeTimeFormat%.[[LocaleData]].\n\t\tconst localeData = RELATIVE_TIME_FORMAT_STATIC_INTERNALS.localeData;\n\n\t\t// Let r be ResolveLocale(%RelativeTimeFormat%.[[AvailableLocales]], requestedLocales, opt, %RelativeTimeFormat%.[[RelevantExtensionKeys]], localeData).\n\t\tconst r = resolveLocale(RELATIVE_TIME_FORMAT_STATIC_INTERNALS.availableLocales, requestedLocales, opt, RELATIVE_TIME_FORMAT_STATIC_INTERNALS.relevantExtensionKeys, localeData);\n\n\t\t// Let locale be r.[[Locale]].\n\t\tconst locale = r.locale;\n\n\t\t// Set relativeTimeFormat.[[Locale]] to locale.\n\t\tsetInternalSlot(this, \"locale\", locale);\n\n\t\t// Set relativeTimeFormat.[[NumberingSystem]] to r_.[[nu]].\n\t\tsetInternalSlot(this, \"numberingSystem\", r.nu);\n\n\t\t// Let dataLocale be r.[[DataLocale]].\n\t\tconst dataLocale = r.dataLocale;\n\n\t\t// Let s be ? GetOption(options, \"style\", \"string\", «\"long\", \"short\", \"narrow\"», \"long\").\n\t\tconst s = options.style != null ? options.style : \"long\";\n\n\t\t// Set relativeTimeFormat.[[Style]] to s.\n\t\tsetInternalSlot(this, \"style\", s);\n\n\t\t// Let numeric be ? GetOption(options, \"numeric\", \"string\", «\"always\", \"auto\"», \"always\").\n\t\tconst numeric = options.numeric != null ? options.numeric : \"auto\";\n\n\t\t// Set relativeTimeFormat.[[Numeric]] to numeric.\n\t\tsetInternalSlot(this, \"numeric\", numeric);\n\n\t\t// Let fields be ! Get(localeData, dataLocale).\n\t\tconst fields = localeData[dataLocale];\n\n\t\t// Assert: fields is an object (see 1.3.3).\n\t\tif (!(fields instanceof Object)) {\n\t\t\tthrow new TypeError(`Expected the LocaleDataEntry for locale: '${dataLocale}' to be an Object`);\n\t\t}\n\n\t\t// Set relativeTimeFormat.[[Fields]] to fields.\n\t\tsetInternalSlot(this, \"fields\", fields);\n\n\t\t// Let relativeTimeFormat.[[NumberFormat]] be ! Construct(%NumberFormat%, « locale »).\n\t\tsetInternalSlot(this, \"numberFormat\", new Intl.NumberFormat(locale));\n\n\t\t// Let relativeTimeFormat.[[PluralRules]] be ! Construct(%PluralRules%, « locale »).\n\t\t// tslint:disable-next-line:no-any\n\t\tsetInternalSlot(\n\t\t\tthis,\n\t\t\t\"pluralRules\",\n\t\t\tnew ((Intl as unknown) as {\n\t\t\t\tPluralRules: IntlPluralRulesConstructor;\n\t\t\t}).PluralRules(locale)\n\t\t);\n\n\t\t// Intl.RelativeTimeFormat instances have an [[InitializedRelativeTimeFormat]] internal slot.\n\t\tsetInternalSlot(this, \"initializedRelativeTimeFormat\", this);\n\t}\n\n\t/**\n\t * Returns an array containing those of the provided locales that are supported without having to fall back to the runtime's default locale.\n\t * @param {Locale | Locales} locales\n\t * @param {SupportedLocalesOptions | undefined} options\n\t * @return {Locales}\n\t */\n\tpublic static supportedLocalesOf(locales: Locale | Locales, options?: SupportedLocalesOptions | undefined): Locales {\n\t\t// Let availableLocales be %RelativeTimeFormat%.[[AvailableLocales]].\n\t\tconst availableLocales = RELATIVE_TIME_FORMAT_STATIC_INTERNALS.availableLocales;\n\n\t\t// Let requestedLocales be ? CanonicalizeLocaleList(locales).\n\t\tconst requestedLocales = Intl.getCanonicalLocales(locales);\n\t\treturn supportedLocales(availableLocales, requestedLocales, options);\n\t}\n\n\t/**\n\t * Adds locale data to the internal slot.\n\t * This API exactly mimics that of the Intl polyfill (https://github.com/andyearnshaw/Intl.js)\n\t * @private\n\t * @internal\n\t * @param {InputLocaleDataEntry} data\n\t * @param {Locale} locale\n\t */\n\tprotected static __addLocaleData({data, locale}: InputLocaleDataEntry): void {\n\t\t// Use the locale as the default one if none is configured\n\t\tconst defaultLocale = getDefaultLocale();\n\t\tif (defaultLocale == null) {\n\t\t\tsetDefaultLocale(locale);\n\t\t}\n\n\t\tRELATIVE_TIME_FORMAT_STATIC_INTERNALS.localeData[locale] = data;\n\t\tif (!RELATIVE_TIME_FORMAT_STATIC_INTERNALS.availableLocales.includes(locale)) {\n\t\t\tRELATIVE_TIME_FORMAT_STATIC_INTERNALS.availableLocales.push(locale);\n\t\t}\n\t}\n\n\t/**\n\t * Method that formats a value and unit according to the locale and formatting options of this Intl.RelativeTimeFormat object.\n\t * @param {number} value\n\t * @param {RelativeTimeUnit} unit\n\t * @return {string}\n\t */\n\tpublic format(value: number, unit: RelativeTimeUnit): string {\n\t\t// Let relativeTimeFormat be the this value.\n\t\tconst relativeTimeFormat = this;\n\n\t\t// If Type(relativeTimeFormat) is not Object, throw a TypeError exception.\n\t\tif (!(relativeTimeFormat instanceof Object)) {\n\t\t\tthrow new TypeError(`Method Intl.RelativeTimeFormat.prototype.format called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// If relativeTimeFormat does not have an [[InitializedRelativeTimeFormat]] internal slot, throw a TypeError exception.\n\t\tif (!hasInternalSlot(relativeTimeFormat, \"initializedRelativeTimeFormat\")) {\n\t\t\tthrow new TypeError(`Method Intl.RelativeTimeFormat.prototype.format called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// Let value be ? ToNumber(value).\n\t\tvalue = Number(value);\n\t\t// Let unit be ? ToString(unit).\n\t\tunit = String(unit) as RelativeTimeUnit;\n\n\t\t// Return ? FormatRelativeTime(relativeTimeFormat, value, unit).\n\t\treturn formatRelativeTime(relativeTimeFormat, value, unit);\n\t}\n\n\t/**\n\t * A version of the 'format' method that returns an array of objects which represent \"parts\" of the object,\n\t * separating the formatted number into its constituent parts and separating it from other surrounding text\n\t * @param {number} value\n\t * @param {RelativeTimeUnit} unit\n\t * @return {UnitPartitions}\n\t */\n\tpublic formatToParts(value: number, unit: RelativeTimeUnit): UnitPartitions {\n\t\t// Let relativeTimeFormat be the this value.\n\t\tconst relativeTimeFormat = this;\n\n\t\t// If Type(relativeTimeFormat) is not Object, throw a TypeError exception.\n\t\tif (!(relativeTimeFormat instanceof Object)) {\n\t\t\tthrow new TypeError(`Method Intl.RelativeTimeFormat.prototype.formatToParts called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// If relativeTimeFormat does not have an [[InitializedRelativeTimeFormat]] internal slot, throw a TypeError exception.\n\t\tif (!hasInternalSlot(relativeTimeFormat, \"initializedRelativeTimeFormat\")) {\n\t\t\tthrow new TypeError(`Method Intl.RelativeTimeFormat.prototype.formatToParts called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// Let value be ? ToNumber(value).\n\t\tvalue = Number(value);\n\t\t// Let unit be ? ToString(unit).\n\t\tunit = String(unit) as RelativeTimeUnit;\n\n\t\t// Return ? FormatRelativeTimeToParts(relativeTimeFormat, value, unit).\n\t\treturn formatRelativeTimeToParts(relativeTimeFormat, value, unit);\n\t}\n\n\t/**\n\t * This method provides access to the locale and options computed during initialization of the object.\n\t * @returns {ResolvedRelativeTimeFormatOptions}\n\t */\n\tpublic resolvedOptions(): ResolvedRelativeTimeFormatOptions {\n\t\t// Let relativeTimeFormat be the this value.\n\t\tconst relativeTimeFormat = this;\n\n\t\t// If Type(relativeTimeFormat) is not Object, throw a TypeError exception.\n\t\tif (!(relativeTimeFormat instanceof Object)) {\n\t\t\tthrow new TypeError(`Method Intl.RelativeTimeFormat.prototype.resolvedOptions called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\t// If relativeTimeFormat does not have an [[InitializedRelativeTimeFormat]] internal slot, throw a TypeError exception.\n\t\tif (!hasInternalSlot(relativeTimeFormat, \"initializedRelativeTimeFormat\")) {\n\t\t\tthrow new TypeError(`Method Intl.RelativeTimeFormat.prototype.resolvedOptions called on incompatible receiver ${this.toString()}`);\n\t\t}\n\n\t\tconst locale = getInternalSlot(this, \"locale\");\n\t\tconst numberingSystem = getInternalSlot(this, \"numberingSystem\");\n\t\tconst style = getInternalSlot(this, \"style\");\n\t\tconst numeric = getInternalSlot(this, \"numeric\");\n\n\t\treturn {\n\t\t\tlocale,\n\t\t\tnumberingSystem,\n\t\t\tstyle,\n\t\t\tnumeric\n\t\t};\n\t}\n}\n","import {RelativeTimeFormat} from \"../relative-time-format/relative-time-format\";\nimport {RelativeTimeUnit} from \"../../unit/relative-time-unit\";\nimport {partitionRelativeTimePattern} from \"../partition-relative-time-pattern/partition-relative-time-pattern\";\n\n/**\n * The FormatRelativeTime abstract operation is called with arguments relativeTimeFormat\n * (which must be an object initialized as a RelativeTimeFormat), value (which must be a Number value),\n * and unit (which must be a String denoting the value unit) and performs the following steps:\n *\n * http://tc39.github.io/proposal-intl-relative-time/#sec-FormatRelativeTime\n * @param {RelativeTimeFormat} relativeTimeFormat\n * @param {number} value\n * @param {RelativeTimeUnit} unit\n * @return {string}\n */\nexport function formatRelativeTime(relativeTimeFormat: RelativeTimeFormat, value: number, unit: RelativeTimeUnit): string {\n\t// Let parts be ? PartitionRelativeTimePattern(relativeTimeFormat, value, unit).\n\tconst parts = partitionRelativeTimePattern(relativeTimeFormat, value, unit);\n\n\t// Let result be an empty String.\n\tlet result = \"\";\n\n\t// For each part in parts, do\n\tfor (const part of parts) {\n\t\t// Set result to the string-concatenation of result and part.[[Value]].\n\t\tresult += part.value;\n\t}\n\n\t// Return result.\n\treturn result;\n}\n","import {RelativeTimeFormat} from \"../relative-time-format/relative-time-format\";\nimport {RelativeTimeUnit} from \"../../unit/relative-time-unit\";\nimport {partitionRelativeTimePattern} from \"../partition-relative-time-pattern/partition-relative-time-pattern\";\nimport {UnitPartitions} from \"../../partition/partition\";\n\n/**\n * The FormatRelativeTimeToParts abstract operation is called with arguments relativeTimeFormat\n * (which must be an object initialized as a RelativeTimeFormat), value (which must be a Number value),\n * and unit (which must be a String denoting the value unit)\n *\n * http://tc39.github.io/proposal-intl-relative-time/#sec-FormatRelativeTimeToParts\n * @param {RelativeTimeFormat} relativeTimeFormat\n * @param {number} value\n * @param {RelativeTimeUnit} unit\n * @return {UnitPartitions}\n */\nexport function formatRelativeTimeToParts(relativeTimeFormat: RelativeTimeFormat, value: number, unit: RelativeTimeUnit): UnitPartitions {\n\treturn partitionRelativeTimePattern(relativeTimeFormat, value, unit);\n}\n","import {RelativeTimeFormat} from \"../relative-time-format/relative-time-format/relative-time-format\";\n\n/**\n * Patches Intl with Intl.RelativeTimeFormat\n */\nexport function patch(): void {\n\tif (typeof Intl === \"undefined\") {\n\t\tthrow new TypeError(\n\t\t\t`Could not define Intl.RelativeTimeFormat: Expected 'Intl' to exist. Remember to include polyfills for Intl.NumberFormat, Intl.getCanonicalLocales, and Intl.PluralRules before applying this polyfill`\n\t\t);\n\t}\n\tIntl.RelativeTimeFormat = RelativeTimeFormat;\n}\n"]}